/**
 * local-task-manager.js
 * Task management functions specifically for the local file system provider (tasks.json)
 */

import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import boxen from 'boxen';
import Table from 'cli-table3';
import readline from 'readline';
// Note: AI Client imports (Anthropic, Perplexity) are kept in task-manager.js or ai-services.js
import ora from 'ora';
import inquirer from 'inquirer';

import {
	CONFIG,
	log,
	readJSON,
	writeJSON,
	findTaskById, // Keep findTaskById here as it operates on the tasks array structure
	enableSilentMode,
	disableSilentMode,
	isSilentMode,
    truncate
} from './utils.js';

import {
	displayBanner,
	getStatusWithColor,
	formatDependenciesWithStatus,
	getComplexityWithColor,
	startLoadingIndicator,
	stopLoadingIndicator,
	createProgressBar
} from './ui.js';

// Dependency manager functions operate on the tasks structure, so they might belong here
// or stay separate. Let's keep them separate for now.
// import {
// 	validateTaskDependencies,
// 	validateAndFixDependencies
// } from './dependency-manager.js';

// --- Core Local Task Operations --- 

/**
 * Generate individual markdown files for each task from tasks.json
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {string} outputDir - Directory to save task files
 * @param {object} options - Additional options
 * @param {object} options.mcpLog - MCP logger object (optional)
 */
function generateTaskFiles(tasksPath, outputDir, options = {}) {
	const { mcpLog } = options;
	const report = (message, level = 'info') => {
		if (mcpLog) {
			mcpLog[level](message);
		} else if (!isSilentMode()) {
			log(level, message);
		}
	};

	report(`Generating task files in directory: ${outputDir}`, 'info');

	try {
		const data = readJSON(tasksPath);
		if (!data || !data.tasks) {
			report('No tasks found to generate files for.', 'warn');
			return;
		}

		if (!fs.existsSync(outputDir)) {
			fs.mkdirSync(outputDir, { recursive: true });
		}

		// Clear existing *.md files in the output directory first
		fs.readdirSync(outputDir).forEach((file) => {
			if (file.endsWith('.md')) {
				fs.unlinkSync(path.join(outputDir, file));
				report(`Removed existing task file: ${file}`, 'debug');
			}
		});

		const totalTasks = data.tasks.reduce((acc, task) => acc + 1 + (task.subtasks ? task.subtasks.length : 0), 0);
		const progressBar = mcpLog ? null : createProgressBar('Generating Task Files', totalTasks);
		let generatedCount = 0;

		data.tasks.forEach((task) => {
			const dependenciesText = formatDependenciesWithStatus(
				task.dependencies,
				data.tasks
			);
            // Try to read complexity score if analysis was run
            let complexityScore = task.complexityScore;
            // This might be better handled by reading the report if needed, but keep simple for now

			const content = `
# Task ${task.id}: ${task.title}

**Status:** ${getStatusWithColor(task.status)}
**Priority:** ${task.priority || 'medium'}
**Dependencies:** ${dependenciesText || 'None'}
**Complexity Score:** ${complexityScore !== undefined && complexityScore !== null ? getComplexityWithColor(complexityScore) : 'N/A'}

## Description
${task.description || '_No description provided._'}

## Implementation Details
${task.details || '_No implementation details provided._'}

## Test Strategy
${task.testStrategy || '_No test strategy provided._'}

---
_Generated by Task Master_
`;
			const filename = `${task.id}. ${task.title.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-')}.md`;
			const filePath = path.join(outputDir, filename);
			fs.writeFileSync(filePath, content.trim());
			generatedCount++;
			if (progressBar) progressBar.update(generatedCount, { taskTitle: task.title });

			if (task.subtasks && task.subtasks.length > 0) {
				task.subtasks.forEach(subtask => {
					const subtaskDependenciesText = formatDependenciesWithStatus(
						subtask.dependencies,
						data.tasks,
						task.subtasks // Include sibling subtasks for dependency check
					);
                    let subComplexityScore = subtask.complexityScore;
					const subtaskContent = `
# Subtask ${subtask.id}: ${subtask.title} (Parent: Task ${task.id})

**Status:** ${getStatusWithColor(subtask.status)}
**Dependencies:** ${subtaskDependenciesText || 'None'}
**Complexity Score:** ${subComplexityScore !== undefined && subComplexityScore !== null ? getComplexityWithColor(subComplexityScore) : 'N/A'}

## Description
${subtask.description || '_No description provided._'}

## Implementation Details
${subtask.details || '_No implementation details provided._'}

---
_Generated by Task Master_
`;
					const subtaskFilename = `${subtask.id}. ${subtask.title.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-')}.md`;
					const subtaskFilePath = path.join(outputDir, subtaskFilename);
					fs.writeFileSync(subtaskFilePath, subtaskContent.trim());
					generatedCount++;
					if (progressBar) progressBar.update(generatedCount, { taskTitle: subtask.title });
				});
			}
		});

		if (progressBar) progressBar.stop();
		report(`Successfully generated ${generatedCount} task files.`, 'success');
	} catch (error) {
		report(`Error generating task files: ${error.message}`, 'error');
		if (!mcpLog) { // Only log stack trace if not called from MCP
			console.error(error);
		}
		// Don't exit, but report the error
	}
}


/**
 * Sets the status of one or more tasks or subtasks in tasks.json.
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {string} taskIdInput - Comma-separated string of task/subtask IDs (e.g., '15', '15.2', '16,17.1')
 * @param {string} newStatus - The new status to set
 * @param {object} options - Additional options { mcpLog, session }
 */
async function setTaskStatus(tasksPath, taskIdInput, newStatus, options = {}) {
	const { mcpLog } = options;
	const report = (message, level = 'info') => {
		if (mcpLog) {
			mcpLog[level](message);
		} else if (!isSilentMode()) {
			log(level, message);
		}
	};

	const outputFormat = mcpLog ? 'json' : 'text';
	let anyUpdated = false; // Flag to track if any status was changed

	try {
		// Read the tasks file
		const data = readJSON(tasksPath);
		if (!data || !data.tasks) {
			throw new Error(`No valid tasks found in ${tasksPath}`);
		}

		const taskIds = taskIdInput.split(',').map((id) => id.trim());
		let updatedTasksInfo = []; // Store info about updated tasks for JSON output

		for (const taskId of taskIds) {
			const { task, parentTask } = findTaskById(data.tasks, taskId);

			if (!task) {
				report(
					`Task or subtask with ID "${taskId}" not found.`,
					'warn'
				);
				continue; // Skip to the next ID
			}

			if (task.status === newStatus) {
				report(
					`Task ${taskId} is already marked as '${newStatus}'. No change needed.`,
					'info'
				);
				continue; // Skip if status is already the target status
			}

			// Update status
			const oldStatus = task.status;
			task.status = newStatus;
			anyUpdated = true; // Mark that at least one update occurred

			updatedTasksInfo.push({
				id: taskId,
				title: task.title,
				oldStatus: oldStatus,
				newStatus: newStatus,
				isSubtask: taskId.includes('.')
			});

			// Log changes based on output format
			if (outputFormat === 'text') {
				const taskType = taskId.includes('.') ? 'Subtask' : 'Task';
				console.log(
					chalk.green(
						`✓ Updated ${taskType} ${chalk.bold(taskId)} (${chalk.yellow(truncate(task.title, 30))}) from '${getStatusWithColor(oldStatus)}' to '${getStatusWithColor(newStatus)}'`
					)
				);
			} else {
				// MCP logging handled by the report function
				report(
					`Updated Task ${taskId} status from '${oldStatus}' to '${newStatus}'`,
					'info'
				);
			}

			// Check for dependent tasks if marking as 'done'
			if (newStatus === 'done') {
				const dependents = data.tasks.filter(
					(t) => t.dependencies && t.dependencies.includes(taskId)
				);
				dependents.forEach((depTask) => {
					// Check if all dependencies for this dependent task are now done
					const allDepsDone = depTask.dependencies.every((depId) => {
						const { task: dep } = findTaskById(data.tasks, depId);
						return dep && dep.status === 'done';
					});

					if (allDepsDone && depTask.status === 'pending') {
						if (outputFormat === 'text') {
							console.log(
								chalk.blue(
									`  ↳ Task ${chalk.bold(depTask.id)} (${chalk.yellow(truncate(depTask.title, 30))}) is now unblocked.`
								)
							);
						} else {
							report(
								`Task ${depTask.id} is now unblocked as dependency ${taskId} is done.`,
								'info'
							);
						}
					}
				});
			}
		} // End loop through taskIds

		if (!anyUpdated) {
			report('No tasks required status updates.', 'info');
			if (outputFormat === 'text') {
				console.log(chalk.yellow('No tasks required status updates.'));
			}
			// Return original data if no updates, or specific structure for MCP
			return outputFormat === 'json' ? { updated: false, tasks: data.tasks } : data;
		}

		// Write updated tasks back to file
		writeJSON(tasksPath, data);
		report('Successfully saved status updates.', 'success');

		// Generate individual task files silently if called from MCP
		if (mcpLog) {
			enableSilentMode();
			await generateTaskFiles(tasksPath, path.dirname(tasksPath), { mcpLog });
			disableSilentMode();
		} else {
			await generateTaskFiles(tasksPath, path.dirname(tasksPath));
		}


		if (outputFormat === 'json') {
			return { updated: true, updates: updatedTasksInfo };
		} else {
			// For text output, we already logged each update individually
			console.log(chalk.green('\nStatus updates saved successfully.'));
			return data; // Return updated data for CLI chaining if needed
		}

	} catch (error) {
		report(`Error setting task status: ${error.message}`, 'error');
		if (outputFormat === 'text') {
			console.error(chalk.red(`Error: ${error.message}`));
			if (CONFIG.debug) {
				console.error(error);
			}
			process.exit(1);
		} else {
			throw error; // Rethrow for MCP
		}
	}
}


/**
 * List tasks from tasks.json in a table format
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {string} statusFilter - Filter tasks by status (optional)
 * @param {boolean} withSubtasks - Include subtasks in the output (optional)
 * @param {string} outputFormat - 'text' or 'json'
 * @returns {object|null} - Task data if outputFormat is 'json', otherwise null.
 */
function listTasks(
	tasksPath,
	statusFilter,
	withSubtasks = false,
	outputFormat = 'text'
) {
	const isJsonOutput = outputFormat === 'json';

	try {
		const data = readJSON(tasksPath);
		if (!data || !data.tasks || data.tasks.length === 0) {
			if (isJsonOutput) {
				return { tasks: [], message: 'No tasks found.' };
			} else {
				console.log(chalk.yellow('No tasks found. Initialize with `task-master init` or `task-master parse-prd`.'));
				return null;
			}
		}

		let tasksToDisplay = data.tasks;

		// Apply status filter if provided
		if (statusFilter) {
			tasksToDisplay = tasksToDisplay.filter(
				(task) => task.status.toLowerCase() === statusFilter.toLowerCase()
			);
			// Also filter subtasks if status filter is applied and withSubtasks is true
			if (withSubtasks) {
				tasksToDisplay = tasksToDisplay.map(task => {
					if (task.subtasks && task.subtasks.length > 0) {
						const filteredSubtasks = task.subtasks.filter(
							(subtask) => subtask.status.toLowerCase() === statusFilter.toLowerCase()
						);
						// Only keep parent task if it matches or has matching subtasks
						if (task.status.toLowerCase() === statusFilter.toLowerCase() || filteredSubtasks.length > 0) {
							return { ...task, subtasks: filteredSubtasks };
						} else {
							return null; // Exclude parent if neither it nor its subtasks match
						}
					} else {
						// Keep parent task if it matches the status filter
						return task.status.toLowerCase() === statusFilter.toLowerCase() ? task : null;
					}
				}).filter(task => task !== null); // Remove null entries
			}
		}


		if (tasksToDisplay.length === 0) {
			if (isJsonOutput) {
				return { tasks: [], message: `No tasks found with status '${statusFilter}'.` };
			} else {
				console.log(chalk.yellow(`No tasks found${statusFilter ? ` with status '${statusFilter}'` : ''}.`));
				return null;
			}
		}


		if (isJsonOutput) {
			// For JSON output, structure the tasks, potentially nesting subtasks if requested
			const outputTasks = tasksToDisplay.map(task => {
				const taskCopy = { ...task }; // Create a copy
				if (!withSubtasks) {
					delete taskCopy.subtasks; // Remove subtasks if not requested
				}
				return taskCopy;
			});
			return { tasks: outputTasks };
		}

		// --- Text Output Formatting ---

		// Determine column widths dynamically
		const terminalWidth = process.stdout.columns || 80; // Default to 80 if columns detection fails
		const idWidth = 5; // Fixed width for ID
		const statusWidth = 12; // Fixed width for Status
		const priorityWidth = 10; // Fixed width for Priority
		const depsWidth = 15; // Fixed width for Dependencies

		// Calculate remaining width for Title and Complexity (approx 2:1 ratio)
		const remainingWidth =
			terminalWidth -
			idWidth -
			statusWidth -
			priorityWidth -
			depsWidth -
			20; // Subtract extra for borders/padding
		const titleWidth = Math.max(20, Math.floor(remainingWidth * 0.6));
		const complexityWidth = Math.max(10, Math.floor(remainingWidth * 0.3));


		// Define table columns
		const table = new Table({
			head: [
				chalk.cyan('ID'),
				chalk.cyan('Title'),
				chalk.cyan('Status'),
				chalk.cyan('Priority'),
				chalk.cyan('Deps'),
				chalk.cyan('Complex'),
			],
			colWidths: [
				idWidth,
				titleWidth,
				statusWidth,
				priorityWidth,
				depsWidth,
				complexityWidth
			],
			style: { head: ['cyan'], border: ['grey'] },
			wordWrap: true, // Enable word wrapping for the Title column
		});

		// Add tasks to the table
		tasksToDisplay.forEach((task) => {
			const complexity = task.complexityScore || 'N/A';

			table.push([
				chalk.bold(task.id),
				safeColor(truncate(task.title, titleWidth - 2), chalk.white, titleWidth), // Truncate title manually
				getStatusWithColor(task.status),
				task.priority || 'medium',
				formatDependenciesWithStatus(task.dependencies, data.tasks),
				getComplexityWithColor(complexity),
			]);

			// Add subtasks if requested
			if (withSubtasks && task.subtasks && task.subtasks.length > 0) {
				task.subtasks.forEach((subtask) => {
					const subComplexity = subtask.complexityScore || 'N/A';
					table.push([
						` ${chalk.grey('└')} ${subtask.id}`, // Indent subtask ID
						safeColor(truncate(`  ${subtask.title}`, titleWidth - 2), chalk.grey, titleWidth), // Indent and truncate title
						`  ${getStatusWithColor(subtask.status)}`,
						'', // No priority for subtasks currently
						`  ${formatDependenciesWithStatus(subtask.dependencies, data.tasks, task.subtasks)}`,
						`  ${getComplexityWithColor(subComplexity)}`,
					]);
				});
			}
		});

		// Display the table
		console.log(table.toString());
		return null; // No data return for text output

	} catch (error) {
		if (isJsonOutput) {
			throw error; // Re-throw for MCP/JSON handling
		} else {
			console.error(chalk.red(`Error listing tasks: ${error.message}`));
			if (CONFIG.debug) {
				console.error(error);
			}
			process.exit(1);
		}
	}
}

// Utility to safely apply chalk color, handling undefined input
function safeColor(text, colorFn, maxLength = 0) {
	const safeText = text === undefined || text === null ? '' : String(text);
	// Truncate before applying color to avoid issues with ANSI codes
	const truncatedText = maxLength > 0 ? truncate(safeText, maxLength) : safeText;
	try {
		return colorFn(truncatedText);
	} catch (e) {
		// Fallback if chalk fails for some reason
		return truncatedText;
	}
}


/**
 * Clear subtasks from specified tasks in tasks.json
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {Array<string>|null} taskIds - Array of task IDs to clear, or null for all
 */
function clearSubtasks(tasksPath, taskIds) {
	log('info', `Clearing subtasks for tasks: ${taskIds ? taskIds.join(', ') : 'ALL'}`);
	try {
		const data = readJSON(tasksPath);
		if (!data || !data.tasks) {
			throw new Error('No valid tasks found.');
		}

		let clearedCount = 0;
		data.tasks.forEach((task) => {
			// If taskIds is null/undefined (meaning clear all) OR task.id is in the list
			if (
				(!taskIds || taskIds.includes(task.id)) &&
				task.subtasks &&
				task.subtasks.length > 0
			) {
				log('debug', `Clearing ${task.subtasks.length} subtasks from task ${task.id}`);
				task.subtasks = [];
				clearedCount++;
			}
		});

		if (clearedCount > 0) {
			writeJSON(tasksPath, data);
			log('success', `Successfully cleared subtasks from ${clearedCount} tasks.`);
			// Regenerate task files after clearing
			generateTaskFiles(tasksPath, path.dirname(tasksPath));
		} else {
			log('info', 'No tasks found with subtasks to clear.');
		}
		return data;
	} catch (error) {
		log('error', `Error clearing subtasks: ${error.message}`);
		console.error(chalk.red(`Error: ${error.message}`));
		if (CONFIG.debug) {
			console.error(error);
		}
		process.exit(1);
	}
}


/**
 * Add a subtask to a parent task in tasks.json, or convert an existing task to a subtask.
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {string} parentId - ID of the parent task
 * @param {string|null} existingTaskId - ID of an existing task to convert, or null
 * @param {object|null} newSubtaskData - Object with title, description, details, etc. for a new subtask, or null
 * @param {boolean} generateFiles - Whether to regenerate task files after adding
 */
async function addSubtask(
	tasksPath,
	parentId,
	existingTaskId = null,
	newSubtaskData = null,
	generateFiles = true
) {
	log('info', `Adding subtask to parent ${parentId}.`);
	if (existingTaskId) log('info', `Converting task ${existingTaskId} to subtask.`);
	if (newSubtaskData) log('info', `Creating new subtask titled: "${newSubtaskData.title}"`);

	try {
		const data = readJSON(tasksPath);
		if (!data || !data.tasks) {
			throw new Error('No valid tasks found.');
		}

		// Find the parent task
		const parentIndex = data.tasks.findIndex((t) => t.id === parentId);
		if (parentIndex === -1) {
			throw new Error(`Parent task with ID ${parentId} not found.`);
		}
		const parentTask = data.tasks[parentIndex];

		// Ensure parent has a subtasks array
		if (!parentTask.subtasks) {
			parentTask.subtasks = [];
		}

		let subtaskToAdd = null;
		let taskToRemoveIndex = -1;

		// Case 1: Convert existing task
		if (existingTaskId) {
			taskToRemoveIndex = data.tasks.findIndex((t) => t.id === existingTaskId);
			if (taskToRemoveIndex === -1) {
				throw new Error(`Task ${existingTaskId} to convert not found.`);
			}
			if (existingTaskId === parentId) {
				throw new Error('Cannot make a task a subtask of itself.');
			}
			subtaskToAdd = { ...data.tasks[taskToRemoveIndex] }; // Copy the task data
			// Assign a new subtask ID
			const nextSubtaskId = parentTask.subtasks.length > 0 ? Math.max(...parentTask.subtasks.map(st => parseInt(st.id.split('.')[1]))) + 1 : 1;
			subtaskToAdd.id = `${parentId}.${nextSubtaskId}`;
			log('debug', `Converted task ${existingTaskId} to subtask ${subtaskToAdd.id}`);
		}
		// Case 2: Create new subtask
		else if (newSubtaskData && newSubtaskData.title) {
			const nextSubtaskId = parentTask.subtasks.length > 0 ? Math.max(...parentTask.subtasks.map(st => parseInt(st.id.split('.')[1]))) + 1 : 1;
			subtaskToAdd = {
				id: `${parentId}.${nextSubtaskId}`,
				title: newSubtaskData.title,
				description: newSubtaskData.description || '',
				details: newSubtaskData.details || '',
				status: newSubtaskData.status || 'pending',
				dependencies: newSubtaskData.dependencies || [],
				// Subtasks don't typically have priority or testStrategy? Add if needed.
			};
			log('debug', `Created new subtask ${subtaskToAdd.id}`);
		} else {
			throw new Error('Must provide either existingTaskId or newSubtaskData with a title.');
		}

		// Add the subtask to the parent
		parentTask.subtasks.push(subtaskToAdd);
        // Sort subtasks by their index
        parentTask.subtasks.sort((a, b) => parseInt(a.id.split('.')[1]) - parseInt(b.id.split('.')[1]));

		// If a task was converted, remove it from the top-level tasks array
		if (taskToRemoveIndex !== -1) {
			data.tasks.splice(taskToRemoveIndex, 1);
			log('debug', `Removed original task ${existingTaskId} from top level.`);
			// Important: Update dependencies pointing to the removed task
			data.tasks.forEach(task => {
				if (task.dependencies && task.dependencies.includes(existingTaskId)) {
					task.dependencies = task.dependencies.map(dep => dep === existingTaskId ? subtaskToAdd.id : dep);
					log('debug', `Updated dependency in task ${task.id}: ${existingTaskId} -> ${subtaskToAdd.id}`);
				}
				// Check subtask dependencies too
				if (task.subtasks) {
					task.subtasks.forEach(st => {
						if (st.dependencies && st.dependencies.includes(existingTaskId)) {
							st.dependencies = st.dependencies.map(dep => dep === existingTaskId ? subtaskToAdd.id : dep);
							log('debug', `Updated dependency in subtask ${st.id}: ${existingTaskId} -> ${subtaskToAdd.id}`);
						}
					});
				}
			});
		}

		// Write changes
		writeJSON(tasksPath, data);
		log('success', `Successfully added subtask ${subtaskToAdd.id} to parent ${parentId}.`);

		// Regenerate files if requested
		if (generateFiles) {
			generateTaskFiles(tasksPath, path.dirname(tasksPath));
		}

		return data; // Return updated data

	} catch (error) {
		log('error', `Error adding subtask: ${error.message}`);
		console.error(chalk.red(`Error: ${error.message}`));
		if (CONFIG.debug) {
			console.error(error);
		}
		process.exit(1);
	}
}


/**
 * Remove a subtask from tasks.json, optionally converting it to a top-level task.
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {string} subtaskId - ID of the subtask to remove (e.g., '15.2')
 * @param {boolean} convertToTask - If true, convert to a top-level task instead of deleting
 * @param {boolean} generateFiles - Whether to regenerate task files
 */
async function removeSubtask(
	tasksPath,
	subtaskId,
	convertToTask = false,
	generateFiles = true
) {
	log('info', `Removing subtask ${subtaskId}. Convert to task: ${convertToTask}`);

	if (!subtaskId || !subtaskId.includes('.')) {
		throw new Error(`Invalid subtask ID format: ${subtaskId}. Expected format like 'parentID.subtaskIndex'.`);
	}

	try {
		const data = readJSON(tasksPath);
		if (!data || !data.tasks) {
			throw new Error('No valid tasks found.');
		}

		// Find the parent task and the subtask index
		const parentId = subtaskId.split('.')[0];
		const parentIndex = data.tasks.findIndex((t) => t.id === parentId);
		if (parentIndex === -1) {
			throw new Error(`Parent task with ID ${parentId} not found for subtask ${subtaskId}.`);
		}
		const parentTask = data.tasks[parentIndex];

		if (!parentTask.subtasks || parentTask.subtasks.length === 0) {
			throw new Error(`Parent task ${parentId} has no subtasks.`);
		}

		const subtaskIndex = parentTask.subtasks.findIndex((st) => st.id === subtaskId);
		if (subtaskIndex === -1) {
			throw new Error(`Subtask ${subtaskId} not found within parent task ${parentId}.`);
		}

		// Get the subtask data before removing/converting
		const subtaskData = parentTask.subtasks[subtaskIndex];

		// Remove the subtask from the parent's array
		parentTask.subtasks.splice(subtaskIndex, 1);
		log('debug', `Removed subtask ${subtaskId} from parent ${parentId}.`);

		// If converting to a top-level task
		if (convertToTask) {
			// Find the next available top-level ID
			const nextId =
				data.tasks.length > 0
					? Math.max(...data.tasks.map((t) => parseInt(t.id))) + 1
					: 1;
			const newTaskId = String(nextId);

			// Create the new top-level task
			const newTask = { ...subtaskData }; // Copy subtask data
			newTask.id = newTaskId; // Assign new top-level ID
			// Reset subtasks array if it exists from a deeper nesting (unlikely but possible)
			newTask.subtasks = [];
			// Inherit parent's priority? Or set default? Let's set default.
			newTask.priority = CONFIG.defaultPriority;
			// Dependencies might need adjustment if they referred to sibling subtasks?
			// For simplicity, keep existing dependencies but log a warning.
			if (newTask.dependencies && newTask.dependencies.some(d => d.startsWith(parentId + '.'))) {
				log('warn', `Converted task ${newTaskId} (from ${subtaskId}) has dependencies on former sibling subtasks. Review dependencies manually: ${newTask.dependencies.join(', ')}`);
			}

			data.tasks.push(newTask);
			log('debug', `Converted subtask ${subtaskId} to new top-level task ${newTaskId}.`);

			// Update dependencies in other tasks/subtasks that pointed to the old subtask ID
			const oldSubtaskId = subtaskId;
			data.tasks.forEach(task => {
				// Check task dependencies
				if (task.dependencies && task.dependencies.includes(oldSubtaskId)) {
					task.dependencies = task.dependencies.map(dep => dep === oldSubtaskId ? newTaskId : dep);
					log('debug', `Updated dependency in task ${task.id}: ${oldSubtaskId} -> ${newTaskId}`);
				}
				// Check subtask dependencies
				if (task.subtasks) {
					task.subtasks.forEach(st => {
						if (st.dependencies && st.dependencies.includes(oldSubtaskId)) {
							st.dependencies = st.dependencies.map(dep => dep === oldSubtaskId ? newTaskId : dep);
							log('debug', `Updated dependency in subtask ${st.id}: ${oldSubtaskId} -> ${newTaskId}`);
						}
					});
				}
			});

			// Sort tasks again after adding
			data.tasks.sort((a, b) => parseInt(a.id) - parseInt(b.id));

		} else {
			// If simply removing, check for dependencies pointing to the removed subtask
			const oldSubtaskId = subtaskId;
			let depsUpdated = false;
			data.tasks.forEach(task => {
				// Check task dependencies
				if (task.dependencies && task.dependencies.includes(oldSubtaskId)) {
					task.dependencies = task.dependencies.filter(dep => dep !== oldSubtaskId);
					log('warn', `Removed dependency on deleted subtask ${oldSubtaskId} from task ${task.id}.`);
					depsUpdated = true;
				}
				// Check subtask dependencies
				if (task.subtasks) {
					task.subtasks.forEach(st => {
						if (st.dependencies && st.dependencies.includes(oldSubtaskId)) {
							st.dependencies = st.dependencies.filter(dep => dep !== oldSubtaskId);
							log('warn', `Removed dependency on deleted subtask ${oldSubtaskId} from subtask ${st.id}.`);
							depsUpdated = true;
						}
					});
				}
			});
			if (depsUpdated) {
				log('warn', 'Some dependencies pointing to the removed subtask were cleaned up. Review task dependencies.');
			}
		}


		// Write changes
		writeJSON(tasksPath, data);
		const action = convertToTask ? 'converted to task' : 'removed';
		log('success', `Subtask ${subtaskId} successfully ${action}.`);

		// Regenerate files if requested
		if (generateFiles) {
			generateTaskFiles(tasksPath, path.dirname(tasksPath));
		}

		return data; // Return updated data

	} catch (error) {
		log('error', `Error removing subtask: ${error.message}`);
		console.error(chalk.red(`Error: ${error.message}`));
		if (CONFIG.debug) {
			console.error(error);
		}
		process.exit(1);
	}
}


/**
 * Remove a task or subtask permanently from tasks.json.
 * @param {string} tasksPath - Path to the tasks.json file
 * @param {string} taskId - ID of the task or subtask to remove (e.g., '5' or '5.2')
 * @returns {Promise<object>} - Updated tasks data
 */
async function removeTask(tasksPath, taskId) {
	log('info', `Attempting to remove task/subtask with ID: ${taskId}`);

	try {
		const data = readJSON(tasksPath);
		if (!data || !data.tasks) {
			throw new Error('No valid tasks found.');
		}

		let taskRemoved = false;
		let subtaskRemovedFromParentId = null;
		const originalTaskCount = data.tasks.length + data.tasks.reduce((sum, t) => sum + (t.subtasks?.length || 0), 0);


		// Check if it's a subtask ID
		if (taskId.includes('.')) {
			const parentId = taskId.split('.')[0];
			const parentIndex = data.tasks.findIndex(t => t.id === parentId);
			if (parentIndex !== -1) {
				const parentTask = data.tasks[parentIndex];
				if (parentTask.subtasks) {
					const subtaskIndex = parentTask.subtasks.findIndex(st => st.id === taskId);
					if (subtaskIndex !== -1) {
						parentTask.subtasks.splice(subtaskIndex, 1);
						taskRemoved = true;
						subtaskRemovedFromParentId = parentId;
						log('debug', `Removed subtask ${taskId} from parent ${parentId}.`);
					}
				}
			}
		} else {
			// If not a subtask ID, try removing a top-level task
			const taskIndex = data.tasks.findIndex(t => t.id === taskId);
			if (taskIndex !== -1) {
				// Check if task has subtasks - warn user or prevent deletion?
				if (data.tasks[taskIndex].subtasks && data.tasks[taskIndex].subtasks.length > 0) {
					// For now, let's allow removing tasks with subtasks but maybe add a --force flag later?
					log('warn', `Removing task ${taskId} which has ${data.tasks[taskIndex].subtasks.length} subtasks.`);
				}
				data.tasks.splice(taskIndex, 1);
				taskRemoved = true;
				log('debug', `Removed top-level task ${taskId}.`);
			}
		}

		if (!taskRemoved) {
			throw new Error(`Task or subtask with ID "${taskId}" not found.`);
		}

		// Clean up dependencies pointing to the removed task/subtask
		let depsUpdated = false;
		data.tasks.forEach(task => {
			// Check task dependencies
			if (task.dependencies && task.dependencies.includes(taskId)) {
				task.dependencies = task.dependencies.filter(dep => dep !== taskId);
				log('debug', `Removed dependency on ${taskId} from task ${task.id}.`);
				depsUpdated = true;
			}
			// Check subtask dependencies
			if (task.subtasks) {
				task.subtasks.forEach(st => {
					if (st.dependencies && st.dependencies.includes(taskId)) {
						st.dependencies = st.dependencies.filter(dep => dep !== taskId);
						log('debug', `Removed dependency on ${taskId} from subtask ${st.id}.`);
						depsUpdated = true;
					}
				});
			}
		});

		if (depsUpdated) {
			log('warn', `Cleaned up dependencies pointing to removed task/subtask ${taskId}. Review remaining dependencies.`);
		}


		// Write changes
		writeJSON(tasksPath, data);
		const finalTaskCount = data.tasks.length + data.tasks.reduce((sum, t) => sum + (t.subtasks?.length || 0), 0);
		log('success', `Successfully removed task/subtask ${taskId}. Total tasks reduced from ${originalTaskCount} to ${finalTaskCount}.`);

		// Regenerate files
		await generateTaskFiles(tasksPath, path.dirname(tasksPath));

		return data; // Return updated data

	} catch (error) {
		log('error', `Error removing task ${taskId}: ${error.message}`);
		// Re-throw for CLI/MCP error handling
		throw error;
	}
}


/**
 * Checks if a task or subtask exists in tasks.json.
 * @param {Array} tasks - The array of task objects.
 * @param {string} taskId - The ID of the task or subtask to check.
 * @returns {boolean} - True if the task/subtask exists, false otherwise.
 */
function taskExists(tasks, taskId) {
    const { task } = findTaskById(tasks, taskId);
    return !!task;
}

/**
 * Adds a new task to the tasks.json file.
 * @param {string} tasksPath - Path to the tasks.json file.
 * @param {Object} taskData - The data for the new task (title, description, details, testStrategy, dependencies, priority).
 * @param {Object} options - Additional options { mcpLog, session, research - used by AI, not directly here }.
 * @returns {Promise<Object>} The newly added task object.
 */
async function addTask(tasksPath, taskData, options = {}) {
    const { mcpLog } = options;
    const report = (message, level = 'info') => {
        if (mcpLog) {
            mcpLog[level](message);
        } else if (!isSilentMode()) {
            log(level, message);
        }
    };

    try {
        const data = readJSON(tasksPath);
        if (!data.tasks) {
            data.tasks = [];
        }

        // Generate new ID
        const newId = generateId(data.tasks); // Use utility from utils.js

        const newTask = {
            id: newId,
            title: taskData.title || 'Untitled Task',
            description: taskData.description || '',
            status: 'pending', // Default status
            dependencies: taskData.dependencies || [],
            priority: taskData.priority || 'medium',
            details: taskData.details || '',
            testStrategy: taskData.testStrategy || '',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
            // subtasks are added via addSubtask
        };

        data.tasks.push(newTask);

        // Sort tasks by ID after adding
        data.tasks.sort((a, b) => a.id - b.id);

        writeJSON(tasksPath, data);

        report(`Added new task ${newTask.id}: "${newTask.title}"`, 'success');

        // Optionally regenerate markdown files
        // Consider if this should be triggered separately or based on an option
        // await generateTaskFiles(tasksPath, path.dirname(tasksPath), options);

        return newTask; // Return the newly created task
    } catch (error) {
        report(`Error adding task: ${error.message}`, 'error');
        throw error; // Re-throw the error to be handled by the caller
    }
}

/**
 * Generates a text report summarizing the complexity analysis results.
 * Reads complexity scores and analysis from tasks.json and writes to complexity_report.txt.
 * @param {string} tasksPath - Path to the tasks.json file.
 * @param {string} [reportPath=\'complexity_report.txt\'] - Path to save the complexity report.
 * @param {object} options - Additional options { mcpLog }.
 */
async function generateComplexityReport(tasksPath, reportPath = 'complexity_report.txt', options = {}) {
    const { mcpLog } = options;
	const reportLog = (message, level = 'info') => { // Renamed to avoid conflict
		if (mcpLog) {
			mcpLog[level](message);
		} else if (!isSilentMode()) {
			log(level, message);
		}
	};

    reportLog(`Generating complexity report: ${reportPath}`, 'info');
    let indicator;
    if (!mcpLog && !isSilentMode()) {
        indicator = startLoadingIndicator('Generating complexity report...');
    }

    try {
        const data = readJSON(tasksPath);
        if (!data || !data.tasks || data.tasks.length === 0) {
            reportLog('No tasks found to generate complexity report.', 'warn');
            if (indicator) stopLoadingIndicator(indicator, 'No tasks found.', 'fail');
            // Optionally write an empty report file or just return
            fs.writeFileSync(reportPath, 'No tasks found to analyze.\n');
            return reportPath; // Indicate report path even if empty
        }

        let reportContent = `# Task Complexity Report\n\nGenerated: ${new Date().toISOString()}\n\n---\n\n`;
        let analysisFound = false;

        data.tasks.forEach(task => {
            reportContent += `## Task ${task.id}: ${task.title}\n`;
            reportContent += `   Priority: ${task.priority || 'medium'}\n`;
            reportContent += `   Status: ${task.status || 'pending'}\n`;

            if (task.complexityScore !== undefined && task.complexityScore !== null) {
                analysisFound = true;
                reportContent += `   Complexity Score: ${task.complexityScore} (${getComplexityWithColor(task.complexityScore)})\n`;
                reportContent += '   Analysis:\n';
                if (task.complexityAnalysis) {
                    reportContent += '     ```\n';
                    reportContent += '     ' + task.complexityAnalysis.replace(/\n/g, '\n     ') + '\n';
                    reportContent += '     ```\n';
                } else {
                    reportContent += '     _No detailed analysis available._\n';
                }
            } else {
                reportContent += `   Complexity Score: N/A\n`;
                reportContent += `   Analysis: _Complexity analysis not performed for this task._\n`;
            }

             // Include subtask complexity if available
             if (task.subtasks && task.subtasks.length > 0) {
                reportContent += `\n   Subtasks:\n`;
                task.subtasks.forEach(subtask => {
                    reportContent += `   - Subtask ${subtask.id}: ${subtask.title}\n`;
                    if (subtask.complexityScore !== undefined && subtask.complexityScore !== null) {
                        analysisFound = true;
                        reportContent += `     Complexity Score: ${subtask.complexityScore} (${getComplexityWithColor(subtask.complexityScore)})\n`;
                        reportContent += '     Analysis:\n';
                        if (subtask.complexityAnalysis) {
                            reportContent += '       ```\n';
                            reportContent += '       ' + subtask.complexityAnalysis.replace(/\n/g, '\n       ') + '\n';
                            reportContent += '       ```\n';
                        } else {
                            reportContent += '       _No detailed analysis available._\n';
                        }
                    } else {
                        reportContent += `     Complexity Score: N/A\n`;
                        reportContent += `     Analysis: _Complexity analysis not performed for this subtask._\n`;
                    }
                });
            }

            reportContent += `\n---\n\n`;
        });

        fs.writeFileSync(reportPath, reportContent);

        if (indicator) {
            if (analysisFound) {
                stopLoadingIndicator(indicator, `Complexity report generated: ${reportPath}`, 'succeed');
            } else {
                stopLoadingIndicator(indicator, `Complexity report generated (no analysis data found): ${reportPath}`, 'warn');
            }
        }
        reportLog(`Complexity report successfully generated at ${reportPath}`, 'success');
        return reportPath; // Return the path for confirmation

    } catch (error) {
        reportLog(`Error generating complexity report: ${error.message}`, 'error');
        if (indicator) stopLoadingIndicator(indicator, 'Error generating complexity report.', 'fail');
         // Re-throw or handle as appropriate for the caller
         throw error;
    }
}

// Export the functions needed by commands.js for the local provider
export {
	// parsePRD, // Moved out or handled differently? Keep in task-manager?
	// updateTasks,
	// updateTaskById,
	// updateSubtaskById,
	setTaskStatus,
	listTasks,
	// expandTask,
	// expandAllTasks,
	clearSubtasks,
	// addTask,
	addSubtask,
	removeSubtask,
	// analyzeTaskComplexity,
	removeTask,
	taskExists,
    findTaskById, // Export findTaskById as it's used internally here and potentially by commands.js
    generateTaskFiles, // Export as it's called by other functions here
    // findNextTask, // Keep in task-manager.js?
    // getTask // Simple read operation - maybe keep in task-manager.js or utils?
    addTask, // Add the new addTask function here
    generateComplexityReport // Added export
}